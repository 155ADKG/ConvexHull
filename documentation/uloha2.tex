%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION 
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[utf8]{inputenc}       %  sdělí, že další text je kódován v utf-8
\usepackage[czech]{babel}         %  zapne české dělení slov a české zvyklosti

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template ... možný smazat ...

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}

%\lhead{\hmwkAuthorName} % Top left header
%\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle} % Top center head
\lhead{\hmwkClass: \hmwkTitle} % Top center head

\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Strana\ \thepage\ /\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\lstloadlanguages{C++} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{language=C++, % Use Perl in this example
        frame=single, % Single frame around code
        basicstyle=\small\ttfamily, % Use small true type font
        keywordstyle=[1]\color{Blue}\bf, % Perl functions bold and blue
        keywordstyle=[2]\color{Purple}, % Perl function arguments purple
        keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
        identifierstyle=, % Nothing special about identifiers                                         
        commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
        stringstyle=\color{Purple}, % Strings are purple
        showstringspaces=false, % Don't put marks in string spaces
        tabsize=5, % 5 spaces per tab
        %
        % Put standard Perl functions not included in the default language here
        morekeywords={rand},
        %
        % Put Perl function parameters here
        morekeywords=[2]{on, off, interp},
        %
        % Put user defined functions here
        morekeywords=[3]{test},
       	%
        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
        numbers=left, % Line numbers on left
        firstnumber=1, % Line numbers start with line 1
        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
        stepnumber=5 % Line numbers go in steps of 5
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\perlscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[caption=#2,label=#1]{#1.cpp}
\end{itemize}
}

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Konvexní obálka} % Assignment title
\newcommand{\hmwkDueDate}{17.\ prosince\ 2016} % Due date
\newcommand{\hmwkClass}{155ADKG - Algoritmy digitální kartografie a GIS} % Course/class
%\newcommand{\hmwkClassTime}{} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Ing. Tomáš Bayer, Ph.D.} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{Bc.\,Petr Bezděka, Bc.\,Šimon Gajzler, Bc.\,Lukáš Středa} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Dne\ \hmwkDueDate}\\
\vspace{0.1in}\large{\textit{\hmwkClassInstructor}}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

\newpage
\tableofcontents
\newpage

%----------------------------------------------------------------------------------------
%	ZADÁNÍ
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem

%\section{Code C++}
%Text before \dots
%\begin{lstlisting}
%for (int i=0; i<iterations;i++)
%{
%do something
%}
%\end{lstlisting}
%Text after it \dots
%\end{document}

%Listing \ref{main} shows a C++ code.

\section{Zadání}
Nad polygonovou mapou implementujete následující algoritmy pro geometrické vyhledávání:\\
\begin{itemize}
\item Ray Crossing Algorithm (varianta s posunem těžiště polygonu).
\item Winding Number Algorithm.
\end{itemize}

Nalezený polygon obsahující zadaný bod q graficky zvýrazněte vhodným způsobem (např. vyplněním, šrafováním,
blikáním). Grafické rozhraní vytvořte s využitím frameworku QT.\\
\\
Pro generování nekonvexních polygonů můžete navrhnout vlastní algoritmus či použít existující geografická data
(např. mapa evropských států).\\
\\
Polygony budou načítány z textového souboru ve Vámi zvoleném formátu. Pro datovou reprezentaci jednotlivých
polygonů použijte špagetový model.\\
\\
%----------------------------------------------------------------------------------------
%	ROZBOR PROBLEMATTIKY
%----------------------------------------------------------------------------------------
\section{Rozbor problematiky}
Problematika určování vzájemné polohy vektorových prvků je v GIS systéméch jedna ze základních úloh. V přednáškách a cvičeních jsme se seznámili s algoritmy  využívanými pro určování polohy bodového prvku vůči polygonovému. V následující části si tyto algoritmy popíšeme.
\subsection{Paprskový algoritmus}
Paprskový algoritmus (Ray Crossing Algorithm) je metoda založená na principu, kdy z určovaného bodu $q$ vedeme polopřímku $r$. Následně je sledovám počet průsečíků $k$ s polygonem. V případě, že bod leží uvnitř polygonu $P$ nabývá $k$ lichých hodnot, v případě bodu ležícího vně polygonu nabývá $k$ sudých hodnot. U~konvexních polygonů se pak $k = 2$ právě v případě bodu vně a $k = 1$ v případě bodu uvnitř polygonu. U singulárních případů je třeba ošetřit situace, kdy bod leží na hraně polygonu (počet průsečíků je roven dvěma) nebo v jeho vrcholu (počet průsečíků je roven jedné nebo dvěma).\\

%\begin{figure}[htbp]
%\begin{center}
%\includegraphics[width=0.4\columnwidth]{} % Example image
%\caption{Paprskový algoritmus (Zdroj: http://geomalgorithms.com/)}
%\label{fig:ray}
%\end{center}
%\end{figure}

Na obrázku \ref{fig:ray} jsou znázorněny dva příklady bodů uvnitř a vně polygonu. Hodnoty $cn$ vyjadřují počet průsečíků vedené polopřímky s hranami polygonu. 

\subsection{Metoda ovíjení}
Metoda ovíjení (Winding Algorithm) je založena na principu sčítání úhlů na určovaném bodě utvořených z~vrcholů polygonů. Sčítání úhlů se řídí pravidlem, kdy se v orientovaném polygonu vždy přičte či odečte úhel mezi vrcholy jedné hrany, podle toho zda je hrana orientována z pohledu určovaného bodu doprava nebo doleva. Součty úhlů mohou nabývat hodnot $\pm2\pi$ pro bod uvnitř polygonu, nula pro bod ležící vně polygonu a jichých hodnot pro bod na hraně či vrcholu.

%\begin{figure}[htbp]
%\begin{center}
%\includegraphics[width=0.4\columnwidth]{} % Example image
%\caption{Metoda ovíjení (Zdroj: http://geomalgorithms.com/)}
%\label{fig:wind}
%\end{center}
%\end{figure}

\section{Problematické situace}
\subsection{Paprskový algortimus}
V paprskovém algoritmu bylo třeba ošetřit singulární případy. Jedná se o situaci, kdy určovaný bod je na hraně či vrcholu polygonu. Nejprve jsme ošetřili situaci, kdy bod leží na hraně, která není rovnoběžná s osou $x$. To bylo vyřešeno ukončením algoritmu s návratovou hodnotou -1, pokud proměnná, která určuje jestli hranu protíná pravá nebo levá polopřímka, navrací hodnotu blízkou nule. Kvůli případu, kdy testovaná hrana je rovnoběžná s osou $x$ a tedy i s testovací přímkou, bylo nutno tento test provádět i pro směr v ose $y$.

\subsection{Metoda ovíjení}
\label{ref:draw}
Ošetření případů, kdy je bod na hraně polygonu bylo vyřešeno přidáním podmínky při rozhodování o poloze bodu. Podmínka řešila případy kdy suma úhlů nabývala hodnot různých od nuly a násobků $2\pi$.

\subsection{Generování polygonů}
Generování nekonvexních polygonů je prováděno generováním náhodných bodů. Ze seznamu bodů byla vytvořena počáteční hrana. Následně byly určovány úhly z počátečního bodu na následující bod v seznamu ve vztahu k výchozí hraně. Vypočtené úhly byly vzestupně seřazeny a tím i určeno pořadí následného spojování bodů. Tento krok vykreslí všechny body vzájemně spojené v jeden polygon. Tento polygon je pak dělen na menší celky. Rozdělování bylo ošetřeno tak, aby s třetinovou pravděpodobností pokaždé došlo k~rozdělení na menší polygony nebo aby byl polygon rozdělen na dvě poloviny.
%----------------------------------------------------------------------------------------
%	UKÁZKA APLIKACE
%----------------------------------------------------------------------------------------
\section{Ukázka vytvořené aplikace}
Výsledná aplikace obsahuje jedno tlačítku \emph{Generate}, kterým uživatel spustí vygenerování náhodných polygonů. Následně si vybere algoritmus z nabýdky comboboxu a kliknutím do mapy spustí výpočet. Pokud je zkoumaný bod nachází v polygonu barevně se zvýrazní.
%\begin{figure}[htbp]
%\begin{center}
%\includegraphics[width=0.73\columnwidth]{} % Example image
% \caption{Přiklad bodu mimo polygon}
%\end{center}
%\end{figure}
%
%\begin{figure}[htbp]
%\begin{center}
%\includegraphics[width=0.73\columnwidth]{} % Example image
% \caption{Příklad bodu uvnitř polygonu}
%\end{center}
%\end{figure}

%----------------------------------------------------------------------------------------
%	DOKUMENTACE
%----------------------------------------------------------------------------------------
\newpage
\section{Documentace}
\subsection{Třída Algorithms}
Třída \emph{Algorithms} obsahuje funkce:
\begin{itemize}
\item jarvis
\item qhull
\item incr
\item graham
\item getPointLinePosition
\item getTwoVectorsOrientation
\item getPointLineDistance
\end{itemize}

\subsubsection{jarvis}
\label{ref:jarvis}
Do této funkce vstupuje jedna proměnná typu  \emph{std::vector$<$QPoint$>$}. Reprezentuje zkoumanou množinu bodů.\\
Výstupem funkce je opět množina bodů uspořádaná do \emph{std::vector$<$QPoint$>$}. Množina bodů obsahuje právě ty body, které tvoří konvexní obálku. Tato funkce ja následně volána ve třídě \emph{Draw}\ref{ref:draw}.
% opravit odkaz v textu
\subsubsection{qhull}
Do této funkce vstupuje jedna proměnná typu  \emph{std::vector$<$QPoint$>$}. Reprezentuje zkoumanou množinu bodů.\\
Výstupem funkce je množina bodů uspořádaná do \emph{std::vector$<$QPoint$>$}, reprezentující konvexní obálku. Tento vektor je následně volán ze třídy \emph{Draw}.

\subsubsection{incr}
Do této funkce vstupuje jedna proměnná typu  \emph{std::vector$<$QPoint$>$}. Reprezentuje zkoumanou množinu bodů.\\
Výstupem funkce je množina bodů uspořádaná do \emph{std::vector$<$QPoint$>$}, reprezentující konvexní obálku. Tento vektor je následně volán ze třídy \emph{Draw}.

\subsubsection{graham}
Do této funkce vstupuje jedna proměnná typu  \emph{std::vector$<$QPoint$>$}. Reprezentuje zkoumanou množinu bodů.\\
Výstupem funkce je množina bodů uspořádaná do \emph{std::vector$<$QPoint$>$}, reprezentující konvexní obálku. Tento vektor je následně volán ze třídy \emph{Draw}.

\subsubsection{getPointLinePosition}
Do této funkce vstupují tři proměnné typu \emph{QPointF}.\\
Výstupem funkce je hodnota typu integer, která reprezentuje polohu zkoumaného bodu (první proměnná) vůči vektoru daného druhou a třetí proměnnou. Výstup nabývá hodnoty 1 pokud je zkoumaný bod v levé polorovině od vektoru, 0 pokud je v pravé polorovině od vektoru a -1 pokud na přímce procházející vektorem.

\subsubsection{getTwoVectorsOrientation}
Do této funkce vstupují čtyři proměnné typu \emph{QPointF}.\\
Výstupem funkce je hodnota typu double, která reprezentuje úhel ve stupních mezi vektory, které jsou tvořeny první a druhou proměnnou a třetí a čtvrtou proměnnou.

\subsubsection{getPointLineDistance}
Do této funkce vstupují tři proměnné typu \emph{QPointF}.\\
Výstupem funkce je hodnota typu double, která reprezentuje vzdálenost zkoumaného bodu (první proměnná) vůči vektoru daného druhou a třetí proměnnou.

\newpage
\subsection{Třída Draw}
Třída Draw obsahuje privátní proměnné:
\begin{itemize}
\item \emph{Qvector$<$QPolygonF$>$} pols
\item \emph{QPointF} cursor
\item \emph{bool} ignoreDrawPols
\item \emph{Qvector$<$bool$>$} results
\item \emph{bool} draw\_what
\end{itemize}

Třída Draw obsahuje dále veřejnou proměnnou:
\begin{itemize}
\item \emph{int} typeAlgorithms
\end{itemize}

Třída Draw obsahuje dále funkce:
\begin{itemize}
\item mousePressEvent
\item paintEvent
\item generatePoint
\item generatePolygons
\item setDrawWhat
\item getCursor
\end{itemize}

\subsubsection{mousePressEvent}
Funkce se aktivuje kliknutím myší do oblasti \emph{QWidgetu} Canvas, který je propojený s třídou \emph{Draw}. Zavolá zvolený algoritmus (\emph{rayAlgorithm},\emph{ windingAlgorithm}) a naplní proměnnou \emph{results}. Následně zavolá funkci \emph{paintEvent} pomocí příkazu \emph{repaint()}.

\subsubsection{paintEvent}
Funkce je volána funkcí \emph{mousePressEvent} nebo po kliknutí na tlačítko \emph{Generate}. Pomocí privátní proměnné \emph{draw\_what} se zavolá funkce \emph{generatePolygons}, která naplní proměnnou \emph{pols} nebo se zvýrazní polygon v němž leží zkoumaný bod.

\subsubsection{generatePoint}
Funkce generující jeden náhodný bod typu\emph{ QPoint}.

\subsubsection{generatePolygons}
Funkce naplní proměnnou \emph{pols} náhodným počtem náhodně generovaných polygonů. Vstupní hodnota označuje počet generovaných bodů (volání funkce \emph{generatePoint}), z kterých se polygony vytváří.\\
Funkce používá dvě funkce z třídy \emph{Algorithms} (\emph{getPointLinePosition}, \emph{getTwoVectorsOrientation}) a třídu \emph{sortByXAsc}. 

\subsubsection{setDrawWhat}
Funkce slouží k přepínání uživatelem zvoleného algoritmu.

\subsubsection{getCursor}
Funkce slouží k získání souřadnic zkoumaního bodu z polohy myši.

\subsection{Třída MainForm}
Třída \emph{MainForm} obsahuje funkce:
\begin{itemize}
\item on\_pushGenerate\_clicked
\item on\_comboBox\_currentIndexChanged
\end{itemize}

\subsubsection{on\_pushGenerate\_clicked}
Funkce se spouští kliknutím uživatele na tlačítko \emph{Generate} a příkazem \emph{repaint()} spustí funkci \emph{paintEvent} ve třídě \emph{Draw}.

\subsubsection{on\_comboBox\_currentIndexChanged}
Funkce se spouští změnou \emph{QComboBoxu} a předá informaci o uživatelem zvoleném algoritmu do třídy \emph{Draw}.

\subsection{sortByXAsc}
Třída \emph{sortByXAsc} slouží funkci \emph{generatePolygons} z třídy \emph{Draw} k vzestupnému setřídění úhlů.
%----------------------------------------------------------------------------------------
%	ZÁVĚR
%----------------------------------------------------------------------------------------
\newpage
\section{Závěr}
Aplikace byla vytvořena dle zadání v QtCreator. Pro určení polohy bodu vůči polygonu byly vytvořeny dva algoritmy, mezi kterými si uživatel volí výběrem z comboBoxu. Generování polygonů probíhá na základě námi vytvořeného algoritmu po stisknutí tlačítka Generate. Uživatel klikem do kreslící oblasti určí skoumaný bod a polygony v nichž se bod nachází se barevně zvýrazní.

%----------------------------------------------------------------------------------------
%	POZNÁMKY
%----------------------------------------------------------------------------------------
%- zadání
%- popis a rozbor problému\\
%- popis algoritmů formálním jazykem\\
%- problematické situace a jejich rozbor (tj. simplexy) + ošetření těchto situací v kódu\\
%- vstupní data, formát vstupních dat, popis\\
%- výstupní data, formát výstupních dat, popis\\
%- printscreen vytvořené aplikace\\
%- dokumentaci: popis tříd, datových položek a jednotlivých metod\\
%- závěr, možné či neřešené problémy, náměty na vylepšení\\
%- seznamy literatury\\

%----------------------------------------------------------------------------------------

\end{document}